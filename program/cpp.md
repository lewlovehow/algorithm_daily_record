1在 C++ 中的 `std::` 容器中间插入元素,应该选什么容器？
在 C++ 中的 `std::` 容器中间插入元素**，可以根据插入效率和访问需求选择合适的容器。
以下是常见容器在**中间插入**场景下的对比：

### ✅ 推荐容器

#### 1. `std::list`（双向链表）

* 插入效率：**O(1)**（已知位置）
* 特点：在任意位置插入/删除都很快
* 用法示例：

  ```cpp
  std::list<int> lst = {1, 2, 4, 5};
  auto it = std::next(lst.begin(), 2); // 指向第3个位置
  lst.insert(it, 3); // 插入3在4前面
  ```

#### 2. `std::deque`（双端队列）

* 插入效率：中间插入**比 vector 快**，但仍为 **O(n)** 级别
* 特点：前后插入快，中间略慢；可选用
* 用法：

  ```cpp
  std::deque<int> dq = {1, 2, 4, 5};
  auto it = dq.begin() + 2;
  dq.insert(it, 3); // 插入3在4前面
  ```

#### 3. `std::vector`

* 插入效率：**O(n)**（需要移动后续元素）
* 适用：数据量小或插入不频繁的情况
* 用法：

  ```cpp
  std::vector<int> vec = {1, 2, 4, 5};
  vec.insert(vec.begin() + 2, 3);
  ```
---
### ❌ 不适合中间插入的容器

| 容器                                          | 原因                             |
| ------------------------------------------- | ------------------------------ |
| `std::array`                                | 固定大小，不能插入                      |
| `std::set` / `std::map`                     | 有序容器，元素位置由 key/比较函数决定，不能指定中间插入 |
| `std::unordered_map` / `std::unordered_set` | 无序，插入顺序无意义                     |
---
### ✅ 总结推荐

| 插入效率优先                | 使用 `std::list`   |
| --------------------- | ---------------- |
| 随机访问需求 + 插入不频繁        | 使用 `std::vector` |
| 折中方案（少量中间插入 + 双端快速访问） | 使用 `std::deque`  |

2 C++中有哪些锁？
C++ 提供了多种用于**线程同步**的锁，主要来自 `<mutex>`、`<shared_mutex>` 等头文件，它们支持互斥、读写共享、递归锁定等多种场景。以下是 C++ 标准库中常见的锁类型及其使用说明：

## 🔒 一、基本互斥锁（互斥量）

| 锁类型                          | 特点                    |
| ---------------------------- | --------------------- |
| `std::mutex`                 | 最常用的基本互斥锁。不可递归。       |
| `std::recursive_mutex`       | 允许同一线程重复加锁（**递归加锁**）。 |
| `std::timed_mutex`           | 支持带超时的锁操作。            |
| `std::recursive_timed_mutex` | 递归锁 + 超时功能。           |

### ✅ 示例：使用 `std::mutex`

```cpp
#include <mutex>
std::mutex mtx;

void critical_section() {
    std::lock_guard<std::mutex> lock(mtx);
    // 线程安全区域
}
```

## 📖 二、共享互斥锁（读写锁）C++17+

| 锁类型                       | 特点                   |
| ------------------------- | -------------------- |
| `std::shared_mutex`       | 支持多个读线程，写线程独占（C++17） |
| `std::shared_timed_mutex` | 加入了超时特性（C++14）       |

### ✅ 示例：使用 `std::shared_mutex`

```cpp
#include <shared_mutex>
std::shared_mutex rw_lock;
void reader() {
    std::shared_lock lock(rw_lock); // 共享锁，多个读线程可以并发
    // 只读操作
}
void writer() {
    std::unique_lock lock(rw_lock); // 独占锁，写操作独占
    // 写操作
}
```
---

## 🛠️ 三、辅助锁管理器（RAII 风格）

| 类型                        | 说明                   |
| ------------------------- | -------------------- |
| `std::lock_guard`         | 自动加锁和解锁，适用于简单场景。     |
| `std::unique_lock`        | 功能更强，可延迟锁、提前解锁、移动构造。 |
| `std::scoped_lock`（C++17） | 可一次锁多个互斥量，避免死锁。      |

### ✅ 示例：使用 `std::scoped_lock` 同时锁多个互斥量

```cpp
std::mutex m1, m2;
void func() {
    std::scoped_lock lock(m1, m2);
    // 已经防止死锁
}
```
---

## 🔄 四、低级锁（不常用）

| 类型                 | 特点                      |
| ------------------ | ----------------------- |
| `std::atomic_flag` | 最轻量的原子布尔锁，适用于自旋锁等自定义结构。 |
| `std::atomic<T>`   | 适用于基本类型原子的替代锁方案。        |

---

## ✅ 总结推荐

| 场景                | 推荐锁类型                                             |
| ----------------- | ------------------------------------------------- |
| 一般线程互斥            | `std::mutex` + `lock_guard`                       |
| 允许递归加锁            | `std::recursive_mutex`                            |
| 有限时间等待锁           | `std::timed_mutex` 或 `unique_lock.try_lock_for()` |
| 多读少写（读写共享）        | `std::shared_mutex`                               |
| 锁多个互斥量防止死锁（C++17） | `std::scoped_lock`                                |
| 构建自旋锁/自定义原子机制     | `std::atomic_flag`                                |


3 C++类型转换有几种？哪种效率更高？ 若用基类指针引用派生类指针或引用时应该用什么类型转换？
C++ 提供的 4 种类型转换
| 类型转换               | 说明                         | 典型用途                   | 是否运行时检查 |
| ------------------ | -------------------------- | ---------------------- | ------- |
| `static_cast`      | 编译期转换                      | 基本类型转换、继承体系中的已知向上/向下转换 | ❌ 否     |
| `dynamic_cast`     | 多态类中的安全运行时转换               | 基类指针/引用 → 派生类指针/引用     | ✅ 是     |
| `const_cast`       | 移除/添加 `const` / `volatile` | 去掉 const 属性修改值         | ❌ 否     |
| `reinterpret_cast` | 强制位级转换                     | 指针类型转换、整数 ↔ 指针等        | ❌ 极度危险  |

当你使用 **基类指针或引用** 指向 **派生类对象** 时，如果需要将其**转换回派生类类型**，应根据具体情况选择以下类型转换方式：

---

## ✅ 正确方式：`dynamic_cast`（**安全的运行时类型检查**）

* 用于**多态类型**（即基类中至少有一个虚函数）。
* 可用于 **指针或引用的向下转型（Downcast）**。
* 在类型不兼容时返回 `nullptr`（指针）或抛出异常（引用）。

### 示例：

```cpp
class Base {
public:
    virtual ~Base() {} // 必须是多态类型
};

class Derived : public Base {
public:
    void foo() {}
};

Base* basePtr = new Derived();

Derived* derivedPtr = dynamic_cast<Derived*>(basePtr);
if (derivedPtr) {
    derivedPtr->foo(); // 安全使用派生类方法
}
```

---

## ⚠️ 其他方式及风险

### 1. `static_cast`（**编译期转换，不检查类型安全**）

* 用于**已知确切类型关系**时的上行/下行转换。
* **没有运行时类型检查**，风险较高。
* 若转换错误，会导致未定义行为。

```cpp
Derived* d = static_cast<Derived*>(basePtr); // 没有安全检查，可能危险
```

✅ 适用：你**非常确定** `basePtr` 实际指向的是 `Derived` 类型。

---

### 2. `reinterpret_cast`（**极少使用**）

* 仅做位级转换。
* **几乎不用于类层次间转换**，会造成严重错误。

```cpp
Derived* d = reinterpret_cast<Derived*>(basePtr); // 非常危险
```

⛔ **避免用于继承体系中的类型转换**。

---

## ❌ 不允许的方式：`const_cast` ❌

* 用于修改 const 属性，**不能用于继承间类型转换**。

---

## ✅ 结论

| 转换方式               | 是否安全   | 是否检查类型  | 是否推荐      |
| ------------------ | ------ | ------- | --------- |
| `dynamic_cast`     | ✅ 安全   | ✅ 运行时检查 | ✅ 推荐（多态）  |
| `static_cast`      | ⚠️ 有风险 | ❌ 不检查   | ⚠️ 谨慎使用   |
| `reinterpret_cast` | ❌ 危险   | ❌ 不检查   | ❌ 禁用      |
| `const_cast`       | ❌ 无效   | ❌       | ❌ 禁用（类层次） |

---

### 🔍 如果你知道 `basePtr` 实际就是 `Derived` 类型，且你控制这个体系结构，可以用 `static_cast`，否则推荐用 `dynamic_cast` 保证类型安全。
static_cast 的效率 更高，因为它在编译时完成类型转换，不涉及运行时类型检查。dynamic_cast 需要在运行时执行类型安全检查（通常依赖 RTTI），因此效率 较低。
4 基类的析构函数为什么应该是虚函数，为什么建议定义为纯虚函数
这是一个在 **C++ 面向对象设计中非常经典** 的面试题。我们分别回答两个问题：

---

## 一、为什么 **基类的析构函数应该是虚函数？**

### ✅ 原因：**确保通过基类指针删除派生类对象时能正确调用派生类析构函数**

### 🔍 示例：

```cpp
class Base {
public:
    virtual ~Base() {
        std::cout << "Base Destructor\n";
    }
};

class Derived : public Base {
public:
    ~Derived() {
        std::cout << "Derived Destructor\n";
    }
};

int main() {
    Base* obj = new Derived();
    delete obj;  // 正确释放：先调用 Derived 析构，再调用 Base 析构
}
```

🔴 如果 `~Base()` **不是虚函数**：

```cpp
class Base {
public:
    ~Base() {
        std::cout << "Base Destructor\n";
    }
};
```

那么 `delete obj;` **只调用 `Base` 的析构函数**，`Derived` 的析构不会被调用，造成资源泄漏！

---

### ✅ 总结：

* 若类有 **派生类**，且你打算 **通过基类指针释放对象**，**析构函数必须设为虚函数**。
* 避免只调用基类析构导致的 **内存泄漏**、**资源未释放** 问题。

---

## 二、为什么基类的析构函数可以是**纯虚函数**？（`virtual ~Base() = 0;`）

这是一个进阶问题，涉及 **抽象类设计**：

### ✅ 原因：**为了让该类不能被实例化，同时仍能通过指针正确析构派生类对象**

```cpp
class Base {
public:
    virtual ~Base() = 0; // 纯虚析构函数
};

Base::~Base() {
    std::cout << "Base Destructor\n";
}

class Derived : public Base {
public:
    ~Derived() {
        std::cout << "Derived Destructor\n";
    }
};

int main() {
    Base* obj = new Derived();
    delete obj;  // 会依次调用 Derived 和 Base 的析构
}
```

> ⚠️ 注意：**纯虚析构函数仍必须实现（提供函数体）！** 否则链接时会报错。

---

### ✅ 总结：

| 需求              | 做法                               |
| --------------- | -------------------------------- |
| 需要多态删除派生类       | 基类析构函数必须 `virtual`               |
| 不希望基类被实例化（抽象接口） | 基类析构函数可以设为 `virtual ~Base() = 0` |
| 使用纯虚析构函数时       | 必须提供定义 `{}`                      |

---
4基类的析构函数为什么是纯虚函数
> **答：**
 在 C++ 中，为了确保通过基类指针或引用释放派生类对象时能正确调用派生类的析构函数，**基类的析构函数应定义为虚函数**。否则只会调用基类析构，派生类资源可能不会释放，造成内存泄漏。
若该基类用于构建抽象接口，**可以将析构函数声明为纯虚函数**以阻止其实例化，但仍必须提供其定义以确保析构流程完整。
| 特性         | 虚析构函数          | 纯虚析构函数              |
| ---------- | -------------- | ------------------- |
| 是否抽象类      | 否              | 是（含纯虚函数 → 抽象类）      |
| 是否必须提供实现体  | 否（可 inline 实现） | ✅ **必须实现**（否则链接报错）  |
| 可否实例化      | 可以             | ❌ 不可以（除非继承并实现所有纯虚）  |
| 用途         | 常规多态析构场景       | 设计抽象接口，同时要求安全析构     |
| 是否可以被继承类覆写 | 可以             | 可以（必须实现）            |
| 会不会自动调用    | 会              | 会（**调用流程和普通虚析构一致**） |

5 智能指针

| 智能指针                 | 特点                              | 使用场景                     |
| -------------------- | ------------------------------- | ------------------------ |
| `std::unique_ptr<T>` | 独占所有权，不可复制，只能移动                 | 管理唯一资源，避免资源泄漏            |
| `std::shared_ptr<T>` | 引用计数，共享所有权，自动析构                 | 多个对象共享资源的生命周期            |
| `std::weak_ptr<T>`   | 弱引用，不增加引用计数，需配合 `shared_ptr` 使用 | 避免 `shared_ptr` 产生循环引用问题 |

| 问题                      | 说明                          |
| ----------------------- | --------------------------- |
| 能否直接赋值给另一个 `unique_ptr` | ❌ 不行，除非使用 `std::move()`     |
| 编译器何时允许赋值               | 当使用 `std::move()`，即转移所有权时 ✅ |
| 原始指针能否赋值给 `unique_ptr`  | ✅ 可以初始化，但不要重复创建两个指针指向同一资源   |
| `shared_ptr` 适合何种情况     | 多处引用同一对象，例如多个模块使用同一配置对象     |
| `weak_ptr` 用于解决什么问题     | `shared_ptr` 循环引用导致的内存泄漏    |

6 左值与右值引用的区别

| 特点       | 左值引用 `T&`               | 右值引用 `T&&`       |
| -------- | ----------------------- | ---------------- |
| 绑定对象     | 只能绑定到左值                 | 只能绑定到右值          |
| 能否延长生命周期 | 左值生命周期本来就长              | 可用右值引用延长临时对象生命周期 |
| 用途       | 修改原对象，传递引用              | 实现移动语义，避免不必要的拷贝  |
| 是否支持绑定常量 | 可以（`const T&` 可绑定左值或右值） | 只能绑定右值           |
| 赋值语义     | 复制语义                    | 移动语义             |
